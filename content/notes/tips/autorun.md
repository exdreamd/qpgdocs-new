---
title: 实现程序开机自启动
date: 2024-07-31T20:02:16+08:00
draft: false
---

在 QuecPython 开发中，实现程序开机自启动可以让您的物联网应用更加智能和便捷。想象一下，您的数据采集设备在通电后自动开始采集数据，并将其上传到云平台，无需任何人工干预——这正是开机自启动的魅力所在。

本文将深入浅出地介绍 QuecPython 程序开机自启动的实现方法，并探讨常见的“开机自启动失败”问题，帮助您更好地理解 QuecPython 的运行机制，并提供一些实用技巧和代码示例，让您的 QuecPython 应用更加健壮和可靠。

## QuecPython 的开机流程：理解自动运行的机制

为了更好地理解 QuecPython 程序的开机自启动机制，我们需要了解 QuecPython 的开机流程，并将其与传统的单片机开发进行对比。

### 传统单片机：简单直接的开机流程

在传统的单片机设备中，例如基于裸机或实时操作系统 (RTOS) 开发的 STM32 程序，程序代码通常会被编译成机器码，并烧录到单片机的 Flash 存储器中。当单片机上电后，它会从 Flash 存储器中读取程序代码，并从预定的起始地址开始执行。这个起始地址通常指向程序的 `main()` 函数，因此 `main()` 函数中的代码会在单片机开机后自动运行。

这种简单的开机自启动机制之所以能够实现，主要是因为程序代码是固定的，并且存储在单片机内部的 Flash 存储器中，单片机上电后可以直接访问和执行这些代码。

### QuecPython：灵活多变的脚本执行

QuecPython 的运行机制与传统的单片机开发截然不同。QuecPython 运行在模块底层的实时操作系统 (RTOS) 之上。当模块上电后，首先启动的是 RTOS，它会进行一系列初始化操作，例如初始化硬件、加载驱动程序、启动系统服务等。这些系统服务，例如电源管理、文件系统、网络服务等，会在后台持续运行，为 QuecPython 的运行提供支撑。

在 RTOS 完成初始化后，它会启动 MicroPython 解释器。MicroPython 解释器可以理解为一个运行在模块上的 Python 虚拟机，它负责读取、解析和执行 Python 代码。不同于传统的单片机程序，QuecPython 程序是以脚本文件的形式存储在模块的文件系统中的，类似于电脑上的硬盘，可以存储多个文件。

**正因为 QuecPython 模块的文件系统中可以存储多个不同的 Python 脚本，我们无法简单地像传统单片机那样，通过预设程序入口的方式实现开机自启动**。为了解决这个问题，MicroPython 设计了一个特殊的机制来实现开机自启动：

1. 运行 `boot.py` 文件： `boot.py` 文件主要用于实现文件系统挂载、备份还原等功能，它被嵌入到 QuecPython 固件中，用户无法修改。
2. 寻找并运行 `main.py` 文件： 如果模块的 `/usr` 目录下存在 `main.py` 文件，MicroPython 解释器会自动加载并运行该文件。

因此，**要实现 QuecPython 程序的开机自启动，您只需要将您的 Python 脚本文件命名为 `main.py` 即可**。

## 开发阶段：避免使用 `main.py`

{{< callout type="warning" >}}

**注意**

强烈建议您**仅在以下情况下**才将脚本文件命名为 `main.py`：

- 您的程序已经完成开发和调试，无需再进行频繁的代码修改。
- 您需要测试程序的开机自启动功能，确保它能够在设备开机后自动运行。

**在程序开发和调试阶段，请勿将文件名修改为 `main.py`**。

{{< /callout >}}

在开发和调试阶段，您的脚本可能并不完善，需要反复调整和修改。您通常需要打断脚本运行并重新上传新的脚本。有的时候，因为脚本设计不够完善，可能无法通过常规方式打断。此时，如果您没有将文件名修改为 `main.py`，则可以通过重启模块来打断脚本运行，因为重启后模块不会自动运行您的脚本，您可以重新连接 REPL 串口，并上传新的脚本文件。

但是，如果您将文件名修改为 `main.py`，则每次模块重启后都会自动运行该脚本，您将无法使用 QPYcom 的 REPL 和文件管理等功能，因为这些功能需要与模块进行通信，而模块正在执行您的脚本，无法响应 QPYcom 的指令。这就好比您正在打电话，这时另一个电话打进来，您就无法接听第二个电话了。

为了避免这种情况，建议您在开发和调试阶段，将脚本文件命名为其他名称，例如 `test.py`，并在需要测试开机自启动功能时，再将文件名修改为 `main.py`。

## 常见问题：`main.py` 为何没有自动运行？

有些用户反馈，即使将脚本文件命名为 `main.py` 并重启设备，程序也没有按预期自动运行。他们观察不到任何程序运行的现象，也看不到任何错误信息。但奇怪的是，在设备开机后，通过 REPL 串口连接到设备，手动再次执行 `main.py` 文件，它又能正常运行。

这通常是由于以下原因导致的：

- **依赖项未就绪**: 在设备开机时，一些模块功能和服务 (例如网络连接、外设驱动等) 可能尚未完成初始化。如果 `main.py` 在这些功能和服务就绪之前就尝试使用它们，就会导致程序运行出错，并提前结束运行。由于程序运行时间很短，用户可能无法观察到任何现象。例如，如果您的 `main.py` 代码在开机后立即尝试连接服务器，但此时还没有完成 4G 网络注册和初始化，就会导致代码执行失败，程序退出。
- **异常处理缺失**: 如果 `main.py` 在运行过程中遇到错误或异常，而没有进行相应的处理，程序就会直接退出，导致用户无法观察到任何运行现象。例如，如果 `main.py` 尝试打开一个尚未创建的文件，就会引发异常，导致程序退出，而不会有任何提示信息。

## 解决方案：提升 `main.py` 的稳定性

为了解决上述问题，并确保 `main.py` 能够在开机时稳定运行，您可以采用以下方法：

### 添加延时：等待模块初始化完成

在 `main.py` 文件的开头添加 5 到 10 秒的延时，可以让模块有足够的时间完成初始化，并确保所有依赖项都已就绪，然后再执行您的代码。例如，您可以使用 `utime.sleep(5)` 函数来实现 5 秒的延时。

### 检查依赖项：确保资源可用

在 `main.py` 文件中，您可以添加代码来检查依赖项是否已经就绪，并在未就绪时进行等待或执行其他操作。例如，如果您的代码需要连接到 4G 网络，您可以在代码中，先利用 `checkNet` 库对网络注册情况进行检查，并在网络注册成功后再执行后续代码。若网络未就绪则进行等待。若等待超时，您可以记录错误信息，或者尝试重新连接。

### 异常处理：捕获错误，避免程序崩溃

在 `main.py` 文件中，您可以使用 `try...except` 语句来捕获和处理程序运行过程中可能出现的异常，避免程序因异常而直接退出。在 `try` 代码块中，您可以放置可能会引发异常的代码，例如打开文件、连接网络等。如果代码引发了异常，程序会跳转到 `except` 代码块中执行异常处理逻辑。您可以在 `except` 代码块中记录错误信息，或者尝试恢复程序的运行，例如重新尝试打开文件或连接网络。

## 代码示例：一个完整的 `main.py` 文件

以下是一个完整的 `main.py` 文件示例，它包含了延时、依赖项检查和异常处理等机制，可以确保程序在开机时稳定运行：

```python
# 增加延时，以等待系统就绪
import utime
utime.sleep(10)

# 引入固件自带的模块
import uos
import checkNet
from machine import Pin
# ......

# 切换运行目录
uos.chdir("/usr")

# 引入用户自行编写的模块
import settings
import myplatform
# ......

# 实例化 checkNet 对象
PROJECT_NAME = "My_Test" # 用户项目名称
PROJECT_VERSION = "0.2.1" # 用户项目版本
checknet = checkNet.CheckNetwork(PROJECT_NAME, PROJECT_VERSION)

# ......

# 用户函数定义
# def test_func():
#     pass

# ......

# 程序入口
if __name__ == '__main__':
    # 进行网络就绪状态检测
    stagecode, statecode = checknet.wait_network_connected(30)
    # 用户可通过两个状态码判断当前的网络状态
    print('stagecode = {}, statecode = {}'.format(stagecode, statecode))

    if stagecode == 3 and statecode == 1:
        try:
        # 执行需要网络连接的代码
        # ...
    	except Exception as e:
        	print("Error:", e)
    else:
        # 网络不正常，执行异常处理代码
        # ......
```

## 总结

通过本文，您应该已经了解了如何实现 QuecPython 程序的开机自启动，以及如何解决常见的“开机自启动失败”问题。希望这些技巧和示例能够帮助您更好地使用 QuecPython，构建更加健壮和可靠的物联网应用。
